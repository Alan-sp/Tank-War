//为了显得我不是很摸，先把多边形碰撞检测的非封装版up上来
#include<bits/stdc++.h>
using namespace std;
const int M=250;
struct node{//点类或向量类
	double x,y;
};
struct Shape{//多边形类
	node k[M];
	int len;
};
Shape tst1,tst2,query_tst;//预判断多边形
node wt1,wt2,wt3;//单纯形中的点
double eps=1e-6;
node Q_ori(node c1,node c2){//求垂直指向原点的方向向量
	double dltx,dlty,dlts;
	node nw;
	if(fabs(c2.y-c1.y)<=eps)
	{
		nw.x=0;
		nw.y=c1.y;
	}
	else if(fabs(c2.x-c1.x)<=eps)
	{
		nw.x=c1.x;
		nw.y=0;
	}
	else
	{
		dlty=(c2.y-c1.y);
		dltx=(c2.x-c1.x);
		dlts=dlty/dltx;
		nw.y=(c1.y-c1.x*dlts)/(dlts*dlts+1);
		nw.x=-dlts*nw.y;
	}
	nw.x=-nw.x;
	nw.y=-nw.y;
	return nw;
}
node Q_core(Shape ts){//求中心
	node nw;
	nw.x=0;
	nw.y=0;
	for(int i=1;i<=ts.len;i++)
	{
		nw.x+=ts.k[i].x;
		nw.y+=ts.k[i].y;
	}
	nw.x/=ts.len;
	nw.y/=ts.len;
	return nw;
}
double num_rep1(node x,node y){//向量数量积
	return x.x*y.x+x.y*y.y;
}
node Support(Shape ts,node fstd){//ts为待求点，fstd为标准方向向量
	node ans=ts.k[1];
	double fstd_len=sqrt(num_rep1(fstd,fstd)),nw=num_rep1(ts.k[1],fstd)/fstd_len;
	for(int i=2;i<=ts.len;i++)
	{
		if(num_rep1(ts.k[i],fstd)/fstd_len>nw)
		{
			nw=num_rep1(ts.k[i],fstd)/fstd_len;
			ans=ts.k[i];
		}
	}
	return ans;
}
double Q_len(node c1,node c2){//求两点间距离
	return sqrt((c1.x-c2.x)*(c1.x-c2.x)+(c1.y-c2.y)*(c1.y-c2.y));
}
double Q_S(node c1,node c2,node c3){
	double x1=Q_len(c1,c2),x2=Q_len(c2,c3),x3=Q_len(c3,c1),p=(x1+x2+x3)/2;
	return sqrt(p*(p-x1)*(p-x2)*(p-x3));
}
double Q_len(node nd,node c1,node c2){//求nd到c1，c2两点确定的直线的距离
	return fabs(((c2.y-c1.y)*nd.x-(c2.x-c1.x)*nd.y)+(c1.y*(c2.x-c1.x)-c1.x*(c2.y-c1.y)))/sqrt((c2.y-c1.y)*(c2.y-c1.y)+(c2.x-c1.x)*(c2.x-c1.x));
}
bool check(){//判断原点是否在三角形中
	node ret;
	ret.x=0;
	ret.y=0;
	return fabs(Q_S(wt1,wt2,wt3)-Q_S(wt1,wt2,ret)-Q_S(wt1,wt3,ret)-Q_S(wt2,wt3,ret))<eps;
}
bool check2(node fstd,node nw){//判断是否退出循环
	return fstd.x*(-nw.x)+fstd.y*(-nw.y)<0;
}
void First(){
	scanf("%d",&tst1.len);
	for(int i=1;i<=tst1.len;i++)
	{
		scanf("%lf%lf",&tst1.k[i].x,&tst1.k[i].y);
	}
	scanf("%d",&tst2.len);
	for(int i=1;i<=tst2.len;i++)
	{
		scanf("%lf%lf",&tst2.k[i].x,&tst2.k[i].y);
	}
	node core1,core2;
	core1=Q_core(tst1);
	core2=Q_core(tst2);
	core1.x-=core2.x;
	core1.y-=core2.y;//core1成为初始方向向量
	for(int i=1;i<=tst1.len;i++)
	{
		for(int j=1;j<=tst2.len;j++)
		{
			query_tst.k[++query_tst.len].x=tst1.k[i].x-tst2.k[j].x;
			query_tst.k[query_tst.len].y=tst1.k[i].y-tst2.k[j].y;
		}
	}
	wt1=Support(query_tst,core1);
	core1.x=-core1.x;
	core1.y=-core1.y;
	wt2=Support(query_tst,core1);
	return ;
}
void usep(){
	node ret;
	ret.x=0;
	ret.y=0;
	double len1,len2;
	len1=Q_len(ret,wt1,wt3);
	len2=Q_len(ret,wt2,wt3);
	if(len1<len2) wt2=wt3;
	else wt1=wt3;
	return ;
}
bool GJK(){//判断是否碰撞以及找到单纯形
	while(1)
	{
		wt3=Support(query_tst,Q_ori(wt1,wt2));
//		cout<<wt1.x<<" "<<wt1.y<<endl;
//		cout<<wt2.x<<" "<<wt2.y<<endl;
		cout<<wt3.x<<" "<<wt3.y<<endl;
		if(check())
		{
			return true;
		}
		if(check2(Q_ori(wt1,wt2),wt3))
		{
			return false;
		}
		usep();
	}
}
//node EPA(){
//}
int main()
{
	First();
	if(GJK())
	{
//		printf("%.2lf %.2lf\n",wt1.x,wt1.y);
//		printf("%.2lf %.2lf\n",wt2.x,wt2.y);
//		printf("%.2lf %.2lf\n",wt3.x,wt3.y);
//		EPA();
	}
	else
	{
		printf("NO COLL!\n");
	}
	return 0;
}
